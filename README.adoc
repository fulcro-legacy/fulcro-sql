= Fulcro SQL

WARNING: This library is under development. The API can change, especially around the graph traversal code. The
general PostgreSQL database component is fairly solid as are the seeding and test utilities.

A utility library for working with SQL databases. It includes the following:

- A `com.stuartsierra` component for starting, building, connection pooling,
  and schema migrations.
- A `with-database` test wrapper for easily writing integration tests. It manages the complete
lifecycle of a test database within each test.
- Database seeding tools with abstract ID support. Useful for testing, development, *and* production.
- Tools that can convert Om Next query syntax into an SQL query.

Thus, it is useful for general SQL development (the graph utilities are relatively small), and
is particularly well-suited when you need to use SQL databases from Fulcro or Om Next.

Connection pooling is provided by http://brettwooldridge.github.io/HikariCP/[HikariCP].
Migrations are provided by http://flywaydb.org/[Flyway].

== Usage

Add `fulcro-sql` to your dependencies:

image::https://img.shields.io/clojars/v/fulcrologic/fulcro-sql.svg[link=https://clojars.org/fulcrologic/fulcro-sql]

Then install a database manager as a component in your web server and inject it into any code that
needs to run graph queries against your SQL database. See <<integrating,Integrating with a Fulcro Server>>
 below.

=== Configuring the SQLDatabaseManager

The current version comes with a PostgreSQLDatabaseManager. SQLDatabaseManager is a protocol that
defines two methods: `start-databases` and `get-dbspec`. It is meant to manage any number of instances
(and their associated datasources).

The PostgreSQLDatabaseManager expects that have a `config` injected into it. It assumes it will take
the same basic form that is generated by Fulcro's server config code. That is to say, `config` has
the following shape (as a component):

```
{:value
  { :sqldbm
    { :database-name {:hikaricp-config "test.properties"
                      :auto-migrate? true
                      :create-drop? true
                      :migrations      ["classpath:migrations/test"]}}}}
```

The top two keys (`:value` and `:sqldbm`) are in the path for the map because the assumption is
you'll be using a more complex config where other data may appear that you do not want to
collide with. If you are using Fulcro server, then this allows you to place this in
your config *file*:

```
{ :port   3000
  :sqldbm { :database-name {:hikaricp-config "test.properties"
                            :auto-migrate?   true
                            :create-drop?    true
                            :migrations      ["classpath:migrations/test"]}}}
```

The allowed keys are:

- `hikaricp-config` : A relative (if on classpath) or absolute (if on disk) path to the Java properties
file (on classpath if relative, or disk if absolute) that contains your desired configuration for
http://brettwooldridge.github.io/HikariCP/[HikariCP] connection pooling.
- `migrations` : A vector of directories that can be prefixed with `classpath:` or `filesystem`.
The named directories will be searched for migrations to run. See http://flywaydb.org/[Flyway]
documentation for the naming conventions of these files.

Example files:

in `resources/migrations` we could place `V1__initial.sql`:

[sql]
```
CREATE TABLE boo (id serial);
```

on the filesystem disk we could write `/usr/local/etc/pool.props`:

```
dataSourceClassName=org.postgresql.ds.PGSimpleDataSource
dataSource.user=test
dataSource.password=
dataSource.databaseName=test
dataSource.portNumber=5432
dataSource.serverName=localhost
```

Then the configuration for this database would be:

```
{:value
  { :sqldbm
    { :test {:hikaricp-config "/usr/local/etc/pool.props"
             :auto-migrate? true
             :create-drop? true
             :migrations      ["classpath:migrations"]}}}}
```

=== Describing Your Schema

In order for most of this library to work you must describe the parts of your schema that you
want to use with it. This can be placed into an EDN map anywhere in your source. It is probably
also possible to automate the generation of it with a little bit of elbow grease against your
database's metadata.

```
(ns schema
  (:require [fulcr-sql.core :as core]))

(def schema {::core/graph->sql {}
             ::core/joins   {:account/members [:account/id :member/account_id]}
             ::core/pks     {:account :id
                             :member  :id}})
```

- `::core/graph->sql` - A map from the graph query property names to SQL. The SQL naming *must* follow the convention
`:table/column`, where the `table` and `column` portions exactly match a table and column name in your
database. This allows you to use whatever UI properties you wish, and map them to their correct
location in the database.
- `::core/joins` - A map whose key is an graph query property that is obtained by following an SQL join, and
whose value is a vector of SQL `:table/col` keywords that describe (in order) the tables and columns
that have to be traversed to resolve the join.
- `::core/pks` - A map whose keys are SQL table names (as keywords) and the columns that represent the PK for that table.
These default to `:id`, so technically you only need them if you used something else.

==== Support for to-one:

When specifying the join sequence, simply wrap it with a call to `(core/to-one ...)`:

```
(def schema { ...
              ::core/joins {:account/settings (core/to-one [:account/settings_id :settings/id])}})
```

would describe a to-one join from the following SQL schema:

```
CREATE TABLE settings (id serial primary key, ...);
CREATE TABLE account (settings_id integer references settings(id), ...);
```

You can include both directions in the joins:

```
(def schema { ...
              ::core/joins {:account/settings (core/to-one [:account/settings_id :settings/id])
                            :settings/account (core/to-one [:settings/id :account/settings_id])}})
```

==== Support for to-many:

To-many is implied by default, but you can make it explicity with a call to `(core/to-many join-seq)`.

==== Support for many-to-many:

WARNING: Support for join tables is in progress. THIS DOES NOT WORK YET.

Many-to-many joins are described with four table/column keywords in the join sequence. For example,
say you had the schema:

```
CREATE TABLE invoice (
  id           SERIAL PRIMARY KEY,
  invoice_date TIMESTAMP NOT NULL DEFAULT now()
);

CREATE TABLE item (
  id   SERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE invoice_items (
  id         SERIAL PRIMARY KEY,
  quantity   SMALLINT NOT NULL,
  invoice_id INTEGER  NOT NULL REFERENCES invoice (id),
  item_id    INTEGER  NOT NULL REFERENCES item (id)
);
```

You would describe the possible joins of interest as:

```
(def schema { ...
              ::core/joins { :invoice/items    (core/to-many [:invoice/id :invoice_items/invoice_id :invoice_items/item_id :item/id])
                             :item/invoices    (core/to-many [:item/id :invoice_items/item_id :invoice_items/invoice_id :invoice/id])}}})
```

This would allow you to issued the graph-query `[{:invoice/items [:item/name]}]` or `[{:item/invoices [:invoice/invoice-date]}]`
relative to an invoice in the former, and an invoice item in the latter.

=== Configuring The Connection Pooling

The connection pooling is provided by http://brettwooldridge.github.io/HikariCP/[HikariCP]. In
order to support testing, development, and adminstrative production tuning we use the properties-based
configuration. This allows you to specify a Java properties file on the classpath or the disk.

The tests for this library have a connection pool set up for
use with PostgreSQL in `test-resources/test.properties`.

=== Writing Migrations

The migration support is provided by Flyway. Here are the basics:

1. Define some direction (typically in `resources`) that will hold SQL files.
2. Tell this library where that is (see configuration above).
3. Indicate during startup that you want migration to happen, or write a separate command-line utility
or something that can run them by starting a database with migrations turned on (you might want to
be paranoid about migrations in production).

See http://flywaydb.org/[Flyway's] documentation for more details. You can also examine the test
suite of this library, which has migrations in
`test-resources/migrations/test`.

=== Seeding Data

The `fulcro-sql.core/seed!` function is a simple but powerful way to put data in your database
for a number of development, testing, *and production* reasons:

- Seeding tests
- Adding data that has to always be in a production database
- As a way to write convenient mutation functions. (e.g. when the creation of an object requires insertions
and relations).

The `seed!` function is row-based, but it includes support for ID generation, relations, and the
return of the IDs of interest. Here is an example:

Say I want to insert two rows: A person and their address. Address has a FK pointer back to the person.
After the insertion, I'd like to know the IDs of the resulting person and address (perhaps for return
to the caller, or for test assertions):

```
(let [rows [(core/seed-row :person {:id :id/joe :name "Joe"})
            (core/seed-row :address {:id :id/address :street "111 Nowhere" :person_id :id/joe})]
      {:keys [id/joe id/address]} (core/seed! db schema rows)]
  ... use `joe` and `address`, which are numbers that correspond to the db row PKs ...)
```

Keywords-as-ids *must* appear in a PK column *before* they are used anywhere else. If you fail to do
this then seeding will fail with a database error, since it won't understand the (unresolved) keyword
as an ID. However, this restriction may cause you problems, since some combinations of inserts
have loops in them.

In order to resolve this there is also a `core/seed-update` function that can be used in the vector of
items to seed. It is needed when you cannot resolve the order of inserts. Say your `person` table
had a `last_updated_by` column whose FK pointed to `person.id`. If Joe last updated Sam and
Sam last updated Joe, you'd need this:

```
(let [rows [(core/seed-row :person {:id :id/joe :name "Joe"})
            (core/seed-row :person {:id :id/sam :name "Sam" :last_updated_by :id/joe})
            (core/seed-update :person :id/joe {:last_updated_by :id/sam})]
      {:keys [id/joe id/sam]} (core/seed! db schema rows)]
  ...)
```

=== Writing Integration Tests

Create an alternate connection pool for your tests, typically in the test source or
resources of the project, that describes where you'd like to run your test database. Typically you
will use the same migrations/schema as your production server.

The combination of seeding and database support makes writing a test very easy. If you're using
`fulcro-spec`, and have placed your migrations and test.properties on the classpath,
then a test specification might look like this:

```
(def test-database {:hikaricp-config "test.properties"
                    :migrations      ["classpath:migrations"]})
(def schema { ... schema as described above ...})

(specification "Doing things to the database"
  (with-database [db test-database]
    (let [{:keys [rowid/a]} (core/seed! db schema [(core/seed-row :table {:id :rowid/a ...})])]
      (jdbc/query db ...)))
```

The `with-database` macro creates a `let`-like binding environment in which your database is
started, migrated, and afterwards cleaned up. You can use `seed!` to populate your database, etc.

The bound variable (`db`) is a simple map, containing nothing but `:datasource`. This is a Java
JDBC `DataSource`, and having it in the map makes it compatible with the `clojure.java.jdbc` library
for convenience.

=== Integrating With a Fulcro Server [[integrating,Integrating with Fulcro Server]]

Fulcro comes with a config component that lays out configuration in a way that is compatible with
the DatabaseManager component(s) in this library. Remember that the database manager can
control any number of databases (of that kind).

```
(easy/make-fulcro-server
  ; inject config into the database manager
  :components {:dbs (component/using (fulcro-sql.core/map->PostgreSQLDatabaseManager {})} [:config])
  :parser-injections #{:dbs})
```

and now your server-side reads and mutations can access `dbs` in the `env`. You can obtain
a dbspec compatible with `clojure.java.jdbc` using `(get-dbspec dbs :dbname)`. This is just a map with
the key `:datasource` whose value is a connection-pooled JDBC data source:

```
(defmutation boo [params]
  (action [{:keys [dbs]}]
    (let [dbspec (fulcro-sql.core/get-dbspec dbs :test)]
      (jdbc/insert! dbspec ...))))
```

Running a query should be relatively easy if your schema is correct. Your query code will
need to derive a "root set". A root set is simply the IDs of the entities that should
root the graph traversal. You might figure this out from query `params`, the user's session,
a special request cookie, or some other criteria.

TODO: Test the following for typos:

```
(defquery-root :accounts
  (value [{:keys [dbs query]} params]
    (let [dbspec (core/get-dbspec dbs :test)
          account-ids-of-interest #{1 2}]
      (core/run-query dbspec schema :account/id account-ids-of-interest))))
```

=== Logging

All of the underlying logging of Flyway, HikariCP, and timbre can use SLF4J. If you configure timbre to
take control of SLF4J, then  you can control logging (level, etc.) from timbre without having to
mess with other configuration. To do this, make sure you have the following dependencies on your
classpath:

```
[org.slf4j/log4j-over-slf4j "1.7.25"]
[org.slf4j/jul-to-slf4j "1.7.25"]
[org.slf4j/jcl-over-slf4j "1.7.25"]
[com.fzakaria/slf4j-timbre "0.3.7"]
```

then you can do things like:

`(timbre/set-level! :debug)`

and see messages from the underlying connection pool and migration libraries.

== Contributing to Fulcro-SQL Development

Please join the `#fulcro` Slack channel in http://clojurians.slack.com. Discuss how you'd like to help.

Contributions should include tests, and all tests should be passing.

Running tests for development:

1. Start a REPL
2. Run `(test-suite)`
3. Browse to http://localhost:8888/fulcro-spec-server-tests.html

The tests are encoded via fulcro-spec, but are just plain clj tests, so you can run them
however you would normally run clojure tests; however, the output and UI are much better
if you use the web-based rendering.



